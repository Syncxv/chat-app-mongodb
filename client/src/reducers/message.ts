import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit'
import axios from 'axios'
import { apiUrl, SOCKET_ACTIONS } from '../constants'
import { MessageType } from '../types'
import { socketClient } from '../pages/_app'
import { channel } from 'diagnostics_channel'
import { AppState } from '../stores/store'
export interface MessageStoreState {
    failed: boolean
    initialized: boolean
    channelMessages: {
        [key: string]: MessageType[]
    }
    currentUserId: string | null
}

const initialState: MessageStoreState = {
    failed: false,
    initialized: true,
    channelMessages: {},
    currentUserId: null
}
interface fetchMessagesReturnType {
    messages: MessageType[]
    channel_id: string
    before: boolean
    cached: boolean
}
interface receiveMessageArgsType {
    payload: { channel_id: string; message: MessageType }
}
// export const initalizeMessages = createAsyncThunk(
//     'messageStore/initalizeUsers',
//     async (): Promise<initUserReturnType> => {
//         return (await socketClient.emit(SOCKET_ACTIONS.USER_INIT)) as initUserReturnType
//     }
// )
interface fetchMessagesArguments {
    channel_id?: string
    before?: string
}
export const fetchMessages = createAsyncThunk(
    'messageStore/fetchMessages',
    async (
        { channel_id, before }: fetchMessagesArguments,
        { getState }
    ): Promise<fetchMessagesReturnType> => {
        const url = `${apiUrl}/channels/${channel_id}/messages${before ? '?before=' + before : ''}`
        if (!channel_id) return { cached: true, messages: [], before: false, channel_id: '' }
        if (!before) {
            const messages = (getState() as AppState).messageStore.channelMessages[channel_id]
            if (Array.isArray(messages)) {
                return { cached: true, messages: [], before: Boolean(before), channel_id }
            }
        }
        const { data } = await axios.get(url)
        return { messages: data, before: Boolean(before), channel_id, cached: false }
    }
)
export const messageCreate = createAsyncThunk(
    'messageStore/messageCreate',
    async ({ content, channel_id }: { content: string; channel_id: string }) => {
        return await socketClient.emit(SOCKET_ACTIONS.CREATE_MESSAGE, {
            message: {
                content,
                channel_id
            }
        })
    }
)
export const messageSlice = createSlice({
    name: 'messageStore',
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {
        receiveMessage: (state, { payload: { channel_id, message } }: receiveMessageArgsType) => {
            state.channelMessages[channel_id].push(message)
        }
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: builder => {
        builder
            .addCase(fetchMessages.pending, (state, actions) => {
                console.log('FETCHING MESSAGES')
            })
            .addCase(fetchMessages.fulfilled, (state, action) => {
                if (!action.payload.cached) {
                    if (!action.payload.before)
                        state.channelMessages[action.payload.channel_id] = action.payload.messages
                    else {
                        console.log(state)
                        state.channelMessages[action.payload.channel_id].unshift(
                            ...(action.payload.messages || [])
                        )
                    }
                }
            })
            .addCase(fetchMessages.rejected, state => {
                state.failed = true
            })
    }
})

export const { receiveMessage } = messageSlice.actions

export default messageSlice.reducer
