import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit'
import axios, { AxiosError } from 'axios'
import { Router } from 'next/router'
import { apiUrl, SOCKET_ACTIONS } from '../constants'
import { socketClient } from '../pages/_app'

import type { AppState, AppThunk } from '../stores/store'
import { FriendType, UserType, UserTypeWithFriends } from '../types'

export interface UserStoreState {
    failed: boolean
    initialized: boolean
    loginOrRegister: {
        loading: boolean
        failed: boolean
        success: boolean
        error?: { feild: string; message: string }
    }
    friends: FriendType[]
    users: {
        [key: string]: UserType
    }
    currentUserId: string | null
    error?: { feild: string; message: string }
}

const initialState: UserStoreState = {
    failed: false,
    loginOrRegister: {
        loading: false,
        failed: false,
        success: false
    },
    initialized: false,
    users: {},
    friends: [],
    currentUserId: null
}
interface initUserReturnType {
    users: UserType[]
    currentUser: UserType
    friends: FriendType[]
}
export const initalizeUsers = createAsyncThunk(
    'userStore/initalizeUsers',
    async (): Promise<initUserReturnType> => {
        return (await socketClient.emit(SOCKET_ACTIONS.USER_INIT)) as initUserReturnType
    }
)
interface loginUserArgumentsTypes {
    username: string
    password: string
}
export const loginUser = createAsyncThunk(
    'userStore/loginUser',
    async (
        { username, password }: loginUserArgumentsTypes,
        { rejectWithValue }
    ): Promise<{ user: UserType } | unknown> => {
        try {
            const { data, statusText } = await axios.post(`${apiUrl}/users/login`, {
                username,
                password
            })
            return data
        } catch (e: any) {
            const error = e.response.data.error || { feild: 'none', message: 'network error idk man' }
            return rejectWithValue(error) as any
        }
    }
)
interface registerUserArgumentsTypes {
    username: string
    password: string
    email: string
}
export const registerUser = createAsyncThunk(
    'userStore/registerUser',
    async (
        { username, password, email }: registerUserArgumentsTypes,
        { rejectWithValue }
    ): Promise<{ user: UserType } | unknown> => {
        try {
            const { data } = await axios.post<{ user: UserType }>(`${apiUrl}/users/register`, {
                username,
                password,
                email
            })
            return data
        } catch (e: any) {
            const error = e.response.data.error || { feild: 'none', message: 'network error idk man' }
            return rejectWithValue(error) as any
        }
    }
)
export const addFriend = createAsyncThunk(
    'userStore/addFriend',
    async (
        { username }: { username: string },
        { rejectWithValue }
    ): Promise<{ user: UserTypeWithFriends }> => {
        try {
            return (
                await axios.post<{ user: UserTypeWithFriends }>(`${apiUrl}/@me/friends/add`, { username })
            ).data
        } catch (e: any) {
            const error = e.response.data.error || { feild: 'none', message: 'network error idk man' }
            return rejectWithValue(error) as any
        }
    }
)
export const userSlice = createSlice({
    name: 'userStore',
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {
        clearLoginOrRegisterState: state => {
            state.loginOrRegister = initialState.loginOrRegister
        }
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: builder => {
        builder
            .addCase(initalizeUsers.pending, state => {
                console.log('INITING USERS')
            })
            .addCase(initalizeUsers.fulfilled, (state, action) => {
                action.payload.users.forEach(e => {
                    state.users[e._id] = e
                })
                state.currentUserId = action.payload.currentUser._id
                state.users[action.payload.currentUser._id] = action.payload.currentUser
                state.friends = action.payload.friends
                state.initialized = true
            })
            .addCase(initalizeUsers.rejected, state => {
                state.failed = true
            })
            .addCase(loginUser.pending, state => {
                console.log('LOGGING THEM IN :O')
                state.loginOrRegister.loading = true
            })
            .addCase(loginUser.fulfilled, (state, action: any) => {
                console.log('LOGIN FUFFILED', action, window)
                window.localStorage.setItem('token', action.payload.accessToken)
                state.loginOrRegister.loading = false
                state.loginOrRegister.success = true
            })
            .addCase(loginUser.rejected, (state, action) => {
                console.log('ACTION IN REJECTED', action)
                state.loginOrRegister.loading = false
                state.loginOrRegister.failed = true
                state.loginOrRegister.error = action.payload as { feild: string; message: string }
            })
            .addCase(registerUser.pending, state => {
                console.log('REGISTERING THEM IN :O')
                state.loginOrRegister.loading = true
            })
            .addCase(registerUser.fulfilled, (state, action) => {
                console.log(action)
                state.loginOrRegister.loading = false
                state.loginOrRegister.success = true
            })
            .addCase(registerUser.rejected, (state, action) => {
                console.log('ACTION IN REJECTED IN REGISTER', action)
                state.loginOrRegister.loading = false
                state.loginOrRegister.failed = true
                state.loginOrRegister.error = action.payload as { feild: string; message: string }
            })
            .addCase(addFriend.pending, state => {
                console.log('ADDING FRIEND')
            })
            .addCase(addFriend.fulfilled, (state, action) => {
                console.log('IN FRIEND FUFFILED', action)
                state.friends = action.payload.user.friends
            })
            .addCase(addFriend.rejected, (state, action) => {
                console.log('ACTION IN REJECTED IN REGISTER', action)
                state.error = action.payload as { feild: string; message: string }
            })
    }
})
export const { clearLoginOrRegisterState } = userSlice.actions
export const getCurrentUser = (state: AppState): UserType | undefined => {
    return state.userStore.users[state.userStore.currentUserId!]
}
export default userSlice.reducer
